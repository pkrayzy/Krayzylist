var commonjsGlobal$1 = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof commonjsGlobal$1 !== 'undefined' ? commonjsGlobal$1 : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
	if (typeof f == "function") {
		var a = function a () {
			if (this instanceof a) {
        return Reflect.construct(f, arguments, this.constructor);
			}
			return f.apply(this, arguments);
		};
		a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}
var sha1 = {exports: {}};
function commonjsRequire(path) {
	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var core = {exports: {}};
var _nodeResolve_empty = {};
var _nodeResolve_empty$1 = Object.freeze({
	__proto__: null,
	default: _nodeResolve_empty
});
var require$$0 = getAugmentedNamespace(_nodeResolve_empty$1);
var hasRequiredCore;
function requireCore () {
	if (hasRequiredCore) return core.exports;
	hasRequiredCore = 1;
	(function (module, exports) {
(function (root, factory) {
			{
				module.exports = factory();
			}
		}(commonjsGlobal, function () {
			var CryptoJS = CryptoJS || (function (Math, undefined$1) {
			    var crypto;
			    if (typeof window !== 'undefined' && window.crypto) {
			        crypto = window.crypto;
			    }
			    if (typeof self !== 'undefined' && self.crypto) {
			        crypto = self.crypto;
			    }
			    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
			        crypto = globalThis.crypto;
			    }
			    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
			        crypto = window.msCrypto;
			    }
			    if (!crypto && typeof commonjsGlobal !== 'undefined' && commonjsGlobal.crypto) {
			        crypto = commonjsGlobal.crypto;
			    }
			    if (!crypto && typeof commonjsRequire === 'function') {
			        try {
			            crypto = require$$0;
			        } catch (err) {}
			    }
			    var cryptoSecureRandomInt = function () {
			        if (crypto) {
			            if (typeof crypto.getRandomValues === 'function') {
			                try {
			                    return crypto.getRandomValues(new Uint32Array(1))[0];
			                } catch (err) {}
			            }
			            if (typeof crypto.randomBytes === 'function') {
			                try {
			                    return crypto.randomBytes(4).readInt32LE();
			                } catch (err) {}
			            }
			        }
			        throw new Error('Native crypto module could not be used to get secure random number.');
			    };
			    var create = Object.create || (function () {
			        function F() {}
			        return function (obj) {
			            var subtype;
			            F.prototype = obj;
			            subtype = new F();
			            F.prototype = null;
			            return subtype;
			        };
			    }());
			    var C = {};
			    var C_lib = C.lib = {};
			    var Base = C_lib.Base = (function () {
			        return {
			            extend: function (overrides) {
			                var subtype = create(this);
			                if (overrides) {
			                    subtype.mixIn(overrides);
			                }
			                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
			                    subtype.init = function () {
			                        subtype.$super.init.apply(this, arguments);
			                    };
			                }
			                subtype.init.prototype = subtype;
			                subtype.$super = this;
			                return subtype;
			            },
			            create: function () {
			                var instance = this.extend();
			                instance.init.apply(instance, arguments);
			                return instance;
			            },
			            init: function () {
			            },
			            mixIn: function (properties) {
			                for (var propertyName in properties) {
			                    if (properties.hasOwnProperty(propertyName)) {
			                        this[propertyName] = properties[propertyName];
			                    }
			                }
			                if (properties.hasOwnProperty('toString')) {
			                    this.toString = properties.toString;
			                }
			            },
			            clone: function () {
			                return this.init.prototype.extend(this);
			            }
			        };
			    }());
			    var WordArray = C_lib.WordArray = Base.extend({
			        init: function (words, sigBytes) {
			            words = this.words = words || [];
			            if (sigBytes != undefined$1) {
			                this.sigBytes = sigBytes;
			            } else {
			                this.sigBytes = words.length * 4;
			            }
			        },
			        toString: function (encoder) {
			            return (encoder || Hex).stringify(this);
			        },
			        concat: function (wordArray) {
			            var thisWords = this.words;
			            var thatWords = wordArray.words;
			            var thisSigBytes = this.sigBytes;
			            var thatSigBytes = wordArray.sigBytes;
			            this.clamp();
			            if (thisSigBytes % 4) {
			                for (var i = 0; i < thatSigBytes; i++) {
			                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
			                }
			            } else {
			                for (var j = 0; j < thatSigBytes; j += 4) {
			                    thisWords[(thisSigBytes + j) >>> 2] = thatWords[j >>> 2];
			                }
			            }
			            this.sigBytes += thatSigBytes;
			            return this;
			        },
			        clamp: function () {
			            var words = this.words;
			            var sigBytes = this.sigBytes;
			            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
			            words.length = Math.ceil(sigBytes / 4);
			        },
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone.words = this.words.slice(0);
			            return clone;
			        },
			        random: function (nBytes) {
			            var words = [];
			            for (var i = 0; i < nBytes; i += 4) {
			                words.push(cryptoSecureRandomInt());
			            }
			            return new WordArray.init(words, nBytes);
			        }
			    });
			    var C_enc = C.enc = {};
			    var Hex = C_enc.Hex = {
			        stringify: function (wordArray) {
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var hexChars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                hexChars.push((bite >>> 4).toString(16));
			                hexChars.push((bite & 0x0f).toString(16));
			            }
			            return hexChars.join('');
			        },
			        parse: function (hexStr) {
			            var hexStrLength = hexStr.length;
			            var words = [];
			            for (var i = 0; i < hexStrLength; i += 2) {
			                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
			            }
			            return new WordArray.init(words, hexStrLength / 2);
			        }
			    };
			    var Latin1 = C_enc.Latin1 = {
			        stringify: function (wordArray) {
			            var words = wordArray.words;
			            var sigBytes = wordArray.sigBytes;
			            var latin1Chars = [];
			            for (var i = 0; i < sigBytes; i++) {
			                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			                latin1Chars.push(String.fromCharCode(bite));
			            }
			            return latin1Chars.join('');
			        },
			        parse: function (latin1Str) {
			            var latin1StrLength = latin1Str.length;
			            var words = [];
			            for (var i = 0; i < latin1StrLength; i++) {
			                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
			            }
			            return new WordArray.init(words, latin1StrLength);
			        }
			    };
			    var Utf8 = C_enc.Utf8 = {
			        stringify: function (wordArray) {
			            try {
			                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
			            } catch (e) {
			                throw new Error('Malformed UTF-8 data');
			            }
			        },
			        parse: function (utf8Str) {
			            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
			        }
			    };
			    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
			        reset: function () {
			            this._data = new WordArray.init();
			            this._nDataBytes = 0;
			        },
			        _append: function (data) {
			            if (typeof data == 'string') {
			                data = Utf8.parse(data);
			            }
			            this._data.concat(data);
			            this._nDataBytes += data.sigBytes;
			        },
			        _process: function (doFlush) {
			            var processedWords;
			            var data = this._data;
			            var dataWords = data.words;
			            var dataSigBytes = data.sigBytes;
			            var blockSize = this.blockSize;
			            var blockSizeBytes = blockSize * 4;
			            var nBlocksReady = dataSigBytes / blockSizeBytes;
			            if (doFlush) {
			                nBlocksReady = Math.ceil(nBlocksReady);
			            } else {
			                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
			            }
			            var nWordsReady = nBlocksReady * blockSize;
			            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
			            if (nWordsReady) {
			                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
			                    this._doProcessBlock(dataWords, offset);
			                }
			                processedWords = dataWords.splice(0, nWordsReady);
			                data.sigBytes -= nBytesReady;
			            }
			            return new WordArray.init(processedWords, nBytesReady);
			        },
			        clone: function () {
			            var clone = Base.clone.call(this);
			            clone._data = this._data.clone();
			            return clone;
			        },
			        _minBufferSize: 0
			    });
			    C_lib.Hasher = BufferedBlockAlgorithm.extend({
			        cfg: Base.extend(),
			        init: function (cfg) {
			            this.cfg = this.cfg.extend(cfg);
			            this.reset();
			        },
			        reset: function () {
			            BufferedBlockAlgorithm.reset.call(this);
			            this._doReset();
			        },
			        update: function (messageUpdate) {
			            this._append(messageUpdate);
			            this._process();
			            return this;
			        },
			        finalize: function (messageUpdate) {
			            if (messageUpdate) {
			                this._append(messageUpdate);
			            }
			            var hash = this._doFinalize();
			            return hash;
			        },
			        blockSize: 512/32,
			        _createHelper: function (hasher) {
			            return function (message, cfg) {
			                return new hasher.init(cfg).finalize(message);
			            };
			        },
			        _createHmacHelper: function (hasher) {
			            return function (message, key) {
			                return new C_algo.HMAC.init(hasher, key).finalize(message);
			            };
			        }
			    });
			    var C_algo = C.algo = {};
			    return C;
			}(Math));
			return CryptoJS;
		}));
	} (core));
	return core.exports;
}
(function (module, exports) {
(function (root, factory) {
		{
			module.exports = factory(requireCore());
		}
	}(commonjsGlobal, function (CryptoJS) {
		(function () {
		    var C = CryptoJS;
		    var C_lib = C.lib;
		    var WordArray = C_lib.WordArray;
		    var Hasher = C_lib.Hasher;
		    var C_algo = C.algo;
		    var W = [];
		    var SHA1 = C_algo.SHA1 = Hasher.extend({
		        _doReset: function () {
		            this._hash = new WordArray.init([
		                0x67452301, 0xefcdab89,
		                0x98badcfe, 0x10325476,
		                0xc3d2e1f0
		            ]);
		        },
		        _doProcessBlock: function (M, offset) {
		            var H = this._hash.words;
		            var a = H[0];
		            var b = H[1];
		            var c = H[2];
		            var d = H[3];
		            var e = H[4];
		            for (var i = 0; i < 80; i++) {
		                if (i < 16) {
		                    W[i] = M[offset + i] | 0;
		                } else {
		                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
		                    W[i] = (n << 1) | (n >>> 31);
		                }
		                var t = ((a << 5) | (a >>> 27)) + e + W[i];
		                if (i < 20) {
		                    t += ((b & c) | (~b & d)) + 0x5a827999;
		                } else if (i < 40) {
		                    t += (b ^ c ^ d) + 0x6ed9eba1;
		                } else if (i < 60) {
		                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
		                } else  {
		                    t += (b ^ c ^ d) - 0x359d3e2a;
		                }
		                e = d;
		                d = c;
		                c = (b << 30) | (b >>> 2);
		                b = a;
		                a = t;
		            }
		            H[0] = (H[0] + a) | 0;
		            H[1] = (H[1] + b) | 0;
		            H[2] = (H[2] + c) | 0;
		            H[3] = (H[3] + d) | 0;
		            H[4] = (H[4] + e) | 0;
		        },
		        _doFinalize: function () {
		            var data = this._data;
		            var dataWords = data.words;
		            var nBitsTotal = this._nDataBytes * 8;
		            var nBitsLeft = data.sigBytes * 8;
		            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
		            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
		            data.sigBytes = dataWords.length * 4;
		            this._process();
		            return this._hash;
		        },
		        clone: function () {
		            var clone = Hasher.clone.call(this);
		            clone._hash = this._hash.clone();
		            return clone;
		        }
		    });
		    C.SHA1 = Hasher._createHelper(SHA1);
		    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
		}());
		return CryptoJS.SHA1;
	}));
} (sha1));
var sha1Exports = sha1.exports;
var SHA1 = getDefaultExportFromCjs(sha1Exports);
const calculateChecksumSHA1 = (content) => {
    const res = SHA1(content);
    return res.toString();
};
const DIFF_PATH_TAG = 'Diff-Path';
const TypesOfChanges = {
    Add: 'a',
    Delete: 'd',
};
const DIFF_DIRECTIVE = 'diff';
const DIFF_DIRECTIVE_NAME = 'name';
const DIFF_DIRECTIVE_CHECKSUM = 'checksum';
const DIFF_DIRECTIVE_LINE = 'lines';
const parseDiffDirective = (s) => {
    if (!s.startsWith(DIFF_DIRECTIVE)) {
        return null;
    }
    const parts = s
        .split(' ')
        .slice(1);
    const nameExists = parts[0].startsWith(DIFF_DIRECTIVE_NAME);
    if (nameExists) {
        return {
            name: parts[0].slice(`${DIFF_DIRECTIVE_NAME}:`.length),
            checksum: parts[1].slice(`${DIFF_DIRECTIVE_CHECKSUM}:`.length),
            lines: Number(parts[2].slice(`${DIFF_DIRECTIVE_LINE}:`.length)),
        };
    }
    return {
        checksum: parts[0].slice(`${DIFF_DIRECTIVE_CHECKSUM}:`.length),
        lines: Number(parts[1].slice(`${DIFF_DIRECTIVE_LINE}:`.length)),
    };
};
const FILE_EXTENSION = '.patch';
const MS_IN_SECONDS = 1000;
const MS_IN_MINUTES = MS_IN_SECONDS * 60;
const MS_IN_HOURS = MS_IN_MINUTES * 60;
const Resolution = {
    Hours: 'h',
    Minutes: 'm',
    Seconds: 's',
};
const assertNever = (x) => {
    throw new Error(`Unexpected value in resolution: ${x}`);
};
const timestampWithResolutionToMs = (timestamp, resolution) => {
    switch (resolution) {
        case Resolution.Hours:
            return timestamp * MS_IN_HOURS;
        case Resolution.Minutes:
            return timestamp * MS_IN_MINUTES;
        case Resolution.Seconds:
            return timestamp * MS_IN_SECONDS;
        default:
            return assertNever(resolution);
    }
};
const parsePatchName = (patchName) => {
    const parts = patchName
        .slice(0, -FILE_EXTENSION.length)
        .split('-');
    if (parts.length === 4) {
        const [name, parsedResolution, parsedEpochTimestamp, parsedTime,] = parts;
        if (!(Object.values(Resolution)).includes(parsedResolution)) {
            throw new Error(`Unrecognized resolution in patch name: ${patchName}`);
        }
        return {
            name,
            resolution: parsedResolution,
            epochTimestamp: Number.parseInt(parsedEpochTimestamp, 10),
            time: Number.parseInt(parsedTime, 10),
        };
    }
    if (parts.length === 3) {
        const [name, parsedEpochTimestamp, parsedTime,] = parts;
        const resolution = Resolution.Hours;
        return {
            name,
            resolution,
            epochTimestamp: Number.parseInt(parsedEpochTimestamp, 10),
            time: Number.parseInt(parsedTime, 10),
        };
    }
    throw new Error(`Cannot parse the patch name: ${patchName}`);
};
const splitByLines = (s) => {
    return s.split(/(?<=\r?\n)/);
};
const createLogger = (verbose) => {
    return (message) => {
        if (verbose) {
            console.log(message);
        }
    };
};
function isErrorWithMessage(error) {
    return (typeof error === 'object'
        && error !== null
        && 'message' in error
        && typeof error.message === 'string');
}
function toErrorWithMessage(maybeError) {
    if (isErrorWithMessage(maybeError)) {
        return maybeError;
    }
    try {
        return new Error(JSON.stringify(maybeError));
    }
    catch {
        return new Error(String(maybeError));
    }
}
function getErrorMessage(error) {
    return toErrorWithMessage(error).message;
}
const AMOUNT_OF_LINES_TO_PARSE = 50;
const parseTag = (tagName, rules) => {
    const maxLines = Math.min(AMOUNT_OF_LINES_TO_PARSE, rules.length);
    for (let i = 0; i < maxLines; i += 1) {
        const rule = rules[i];
        if (!rule) {
            continue;
        }
        const search = `! ${tagName}: `;
        const indexOfSearch = rule.indexOf(search);
        if (indexOfSearch >= 0) {
            return rule.substring(indexOfSearch + search.length).trim();
        }
    }
    return null;
};
const AcceptableHttpStatusCodes = {
    NotFound: 404,
    NoContent: 204,
    Ok: 200,
};
const parseRcsOperation = (rcsOperation) => {
    const [operationInfo, operationCounter] = rcsOperation.split(' ');
    const typeOfOperation = operationInfo[0];
    const startIndex = Number(operationInfo.slice(1)) - 1;
    const numberOfLines = Number(operationCounter);
    if (typeOfOperation !== TypesOfChanges.Add && typeOfOperation !== TypesOfChanges.Delete) {
        throw new Error(`Operation is not valid: cannot parse type: ${rcsOperation}`);
    }
    if (Number.isNaN(startIndex)) {
        throw new Error(`Operation is not valid: cannot parse index: ${rcsOperation}`);
    }
    if (Number.isNaN(numberOfLines)) {
        throw new Error(`Operation is not valid: cannot parse number of lines: ${rcsOperation}`);
    }
    return {
        typeOfOperation,
        startIndex,
        numberOfLines,
    };
};
const applyRcsPatch = (filterContent, patch, checksum) => {
    const lines = filterContent.slice();
    let currentOffset = 0;
    for (let index = 0; index < patch.length; index += 1) {
        const patchLine = patch[index];
        if (patchLine === '') {
            continue;
        }
        const parsedRcsOperation = parseRcsOperation(patchLine);
        const { typeOfOperation, startIndex, numberOfLines, } = parsedRcsOperation;
        const startIndexWithOffset = startIndex + currentOffset;
        if (typeOfOperation === TypesOfChanges.Delete) {
            lines.splice(startIndexWithOffset, numberOfLines);
            currentOffset -= numberOfLines;
        }
        if (typeOfOperation === TypesOfChanges.Add) {
            const stringsToAdd = [];
            let nStringsToAdd = numberOfLines;
            let scanFrom = index + 1;
            while (nStringsToAdd > 0 && scanFrom < patch.length) {
                stringsToAdd.push(patch[scanFrom]);
                scanFrom += 1;
                nStringsToAdd -= 1;
            }
            index += stringsToAdd.length;
            if (startIndexWithOffset < 0) {
                lines.unshift(...stringsToAdd);
            }
            else if (startIndexWithOffset > lines.length) {
                lines.push(...stringsToAdd);
            }
            else {
                lines.splice(startIndexWithOffset + 1, 0, ...stringsToAdd);
            }
            currentOffset += numberOfLines;
        }
    }
    const updatedFilter = lines.join('');
    if (checksum) {
        const c = calculateChecksumSHA1(updatedFilter);
        if (c !== checksum) {
            throw new Error('Checksums are not equal.');
        }
    }
    return updatedFilter;
};
const checkPatchExpired = (diffPath) => {
    const { resolution, epochTimestamp, time, } = parsePatchName(diffPath);
    const createdMs = timestampWithResolutionToMs(epochTimestamp, resolution);
    const ttlMs = timestampWithResolutionToMs(time, resolution);
    return Date.now() > createdMs + ttlMs;
};
const downloadFile = async (baseURL, fileUrl, isFileHostedViaNetworkProtocol, isRecursiveUpdate, log) => {
    try {
        const response = await fetch(new URL(fileUrl, `${baseURL}/`));
        if (!isFileHostedViaNetworkProtocol && !(response.status >= 200 && response.status < 300)) {
            log(`Error during file request: ${response.status} ${response.statusText}`);
            return null;
        }
        if (isFileHostedViaNetworkProtocol) {
            const acceptableHttpStatusCodes = Object.values(AcceptableHttpStatusCodes);
            if (!acceptableHttpStatusCodes.includes(response.status)) {
                const err = `Error during network request: ${response.status} ${response.statusText}`;
                log(err);
                throw new Error(err);
            }
        }
        if ((response.status === AcceptableHttpStatusCodes.NotFound
            || response.status === AcceptableHttpStatusCodes.NoContent) && !isRecursiveUpdate) {
            log('Update is not available.');
            return null;
        }
        const data = await response.text();
        if (response.status === AcceptableHttpStatusCodes.Ok && data === '') {
            if (!isRecursiveUpdate) {
                log('Update is not available.');
            }
            return null;
        }
        return splitByLines(data);
    }
    catch (e) {
        if (!isFileHostedViaNetworkProtocol) {
            log(`Error during file request to "${baseURL}"/"${fileUrl}": ${getErrorMessage(e)}`);
            return null;
        }
        throw new Error(`Error during network request: ${getErrorMessage(e)}`, { cause: e });
    }
};
const extractBaseUrl = (filterUrl) => {
    let splitDelimeter = '/';
    if (filterUrl.includes('\\')) {
        splitDelimeter = '\\';
    }
    return filterUrl
        .split(splitDelimeter)
        .slice(0, -1)
        .join(splitDelimeter);
};
const applyPatch = async (params) => {
    const applyPatchWrapper = async (innerParams) => {
        const { filterUrl, filterContent, verbose = false, callStack, } = innerParams;
        const filterLines = splitByLines(filterContent);
        const diffPath = parseTag(DIFF_PATH_TAG, filterLines)?.split('#')[0];
        const log = createLogger(verbose);
        if (!diffPath) {
            return null;
        }
        if (!checkPatchExpired(diffPath)) {
            return filterContent;
        }
        let patch = [];
        try {
            const baseUrl = extractBaseUrl(filterUrl);
            const res = await downloadFile(baseUrl, diffPath, baseUrl.startsWith('http://') || baseUrl.startsWith('https://'), callStack > 0, log);
            if (res === null) {
                return filterContent;
            }
            patch = res;
        }
        catch (e) {
            throw new Error(`Error during downloading patch file from "${diffPath}": ${getErrorMessage(e)}`, { cause: e });
        }
        let updatedFilter = '';
        try {
            const diffDirective = parseDiffDirective(patch[0]);
            updatedFilter = applyRcsPatch(filterLines,
            diffDirective ? patch.slice(1) : patch, diffDirective ? diffDirective.checksum : undefined);
        }
        catch (e) {
            throw new Error(`Error during applying the patch from "${diffPath}": ${getErrorMessage(e)}`, { cause: e });
        }
        try {
            const recursiveUpdatedFilter = await applyPatchWrapper({
                filterUrl,
                filterContent: updatedFilter,
                callStack: callStack + 1,
                verbose,
            });
            if (recursiveUpdatedFilter === null) {
                return updatedFilter;
            }
            return recursiveUpdatedFilter;
        }
        catch (e) {
            return updatedFilter;
        }
    };
    return applyPatchWrapper(Object.assign(params, { callStack: 0 }));
};
const DiffUpdater = {
    applyPatch,
};
var DiffUpdater_1 = DiffUpdater;

/**
 * This file is part of AdGuard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * AdGuard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AdGuard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with AdGuard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */
const FiltersDownloaderCreator = (FileDownloadWrapper) => {
    const CONDITION_IF_DIRECTIVE_START = '!#if';
    const CONDITION_ELSE_DIRECTIVE_START = '!#else';
    const CONDITION_DIRECTIVE_END = '!#endif';
    const CONDITION_OPERATOR_NOT = '!';
    const CONDITION_OPERATOR_AND = '&&';
    const CONDITION_OPERATOR_OR = '||';
    const CONDITION_BRACKET_OPEN_CHAR = '(';
    const CONDITION_BRACKET_CLOSE_CHAR = ')';
    const INCLUDE_DIRECTIVE = '!#include';
    const REGEXP_ABSOLUTE_URL = /^([a-z]+:\/\/|\/\/)/i;
    const REGEXP_EXTERNAL_ABSOLUTE_URL = /^((?!file)[a-z]+:\/\/|\/\/)/i;
    /**
     * Checks if the opening and closing brackets in a string are balanced.
     *
     * @param str The input string to check for bracket balance.
     * @returns Returns `true` if the brackets are balanced, `false` otherwise.
     */
    const checkBracketsBalance = (str) => {
        let depth = 0;
        for (let i = 0; i < str.length; i += 1) {
            if (str[i] === CONDITION_BRACKET_OPEN_CHAR) {
                // if the char is an opening parenthesis, then we increase the depth
                depth += 1;
            }
            else if (str[i] === CONDITION_BRACKET_CLOSE_CHAR) {
                // if the char is a closing parenthesis, then we decrease the depth
                depth -= 1;
            }
            //  if the depth is negative we have a closing parenthesis
            //  before any matching opening parenthesis
            if (depth < 0) {
                return false;
            }
        }
        // If the depth is not null then a closing parenthesis is missing
        if (depth > 0) {
            return false;
        }
        return true;
    };
    /**
     * Parses url and returns its origin.
     *
     * @param url URL to parse.
     *
     * @returns URL origin if url can be parsed.
     * @throws If url cannot be parsed.
     */
    const getUrlOrigin = (url) => {
        try {
            const { origin } = new URL(url);
            return origin;
        }
        catch (e) {
            throw new Error(`Invalid url: '${url}'`);
        }
    };
    /**
     * Get the `filterUrlOrigin` from url for relative path resolve.
     *
     * @param url Filter file URL.
     * @param filterUrlOrigin Existing origin url.
     * @returns Valid origin url.
     */
    const getFilterUrlOrigin = (url, filterUrlOrigin) => {
        if (filterUrlOrigin) {
            return filterUrlOrigin;
        }
        return url.substring(0, url.lastIndexOf('/'));
    };
    /**
     * Finds end of condition block started with startIndex.
     *
     * @param rules Array of all rules.
     * @param endDirective End directive for the condition block — `!#else` or `!#endif`.
     * @param startIndex Index of the start for presumed condition block.
     * @param endIndex Index of the end for presumed condition block,
     * needed for `!#else` directive if index of `!#endif` was found before to limit the search.
     *
     * @returns Index of the end of the condition block for the `endDirective`.
     */
    const findConditionBlockEnd = (rules, endDirective, startIndex, endIndex) => {
        const stack = [];
        for (let i = startIndex; i < endIndex; i += 1) {
            const rule = rules[i];
            if (rule.startsWith(CONDITION_IF_DIRECTIVE_START)) {
                stack.push(CONDITION_IF_DIRECTIVE_START);
            }
            else if (rule.startsWith(endDirective)) {
                if (stack.length > 0) {
                    stack.pop();
                }
                else {
                    return i;
                }
            }
        }
        return -1;
    };
    /**
     * Resolves a conditional expression to a boolean value based
     * on defined properties.
     *
     * @param expression The conditional expression to resolve.
     * @param definedProperties An object containing defined properties for evaluation.
     *
     * @throws Throws an error if the expression is empty.
     *
     * @returns Returns `true` if the expression evaluates to `true` or a defined
     * property exists; otherwise, returns `false`.
     */
    const resolveConditionConstant = (expression, definedProperties) => {
        if (!expression) {
            throw new Error('Invalid directives: Empty condition');
        }
        const trimmedExpression = expression.trim();
        if (trimmedExpression === 'true') {
            return true;
        }
        const expressionAsKey = trimmedExpression;
        if (definedProperties?.[expressionAsKey] === true) {
            return true;
        }
        return false;
    };
    /**
     * Resolves a conditional expression and returns whether the expression
     * evaluates to `true` or `false` based on defined properties.
     *
     * @param rawExpression The raw conditional expression to resolve.
     * @param definedProperties An object containing defined expressions for
     * condition resolution.
     *
     * @returns Boolean `true` if the expression evaluates to `true`,
     * `false` otherwise.
     *
     * @throws Error If the expression is empty or contains incorrect brackets.
     */
    const resolveExpression = (rawExpression, definedProperties) => {
        if (!rawExpression) {
            throw new Error('Invalid directives: Empty condition');
        }
        const expression = rawExpression.trim();
        if (!checkBracketsBalance(expression)) {
            throw new Error(`Invalid directives: Incorrect brackets: ${expression}`);
        }
        // Replace bracketed expressions
        const openBracketIndex = expression.lastIndexOf(CONDITION_BRACKET_OPEN_CHAR);
        if (openBracketIndex !== -1) {
            const endBracketIndex = expression.indexOf(CONDITION_BRACKET_CLOSE_CHAR, openBracketIndex);
            const innerExpression = expression.substring(openBracketIndex + 1, endBracketIndex);
            const innerResult = resolveExpression(innerExpression, definedProperties);
            const resolvedInner = expression.substring(0, openBracketIndex)
                + innerResult + expression.substring(endBracketIndex + 1);
            return resolveExpression(resolvedInner, definedProperties);
        }
        let result;
        // Resolve logical operators
        const indexOfAndOperator = expression.indexOf(CONDITION_OPERATOR_AND);
        const indexOfOrOperator = expression.indexOf(CONDITION_OPERATOR_OR);
        const indexOfNotOperator = expression.indexOf(CONDITION_OPERATOR_NOT);
        if (indexOfOrOperator !== -1) {
            result = resolveExpression(expression.substring(0, indexOfOrOperator - 1), definedProperties) || resolveExpression(expression.substring(indexOfOrOperator + CONDITION_OPERATOR_OR.length, expression.length), definedProperties);
        }
        else if (indexOfAndOperator !== -1) {
            result = resolveExpression(expression.substring(0, indexOfAndOperator - 1), definedProperties) && resolveExpression(expression.substring(indexOfAndOperator + CONDITION_OPERATOR_AND.length, expression.length), definedProperties);
        }
        else if (indexOfNotOperator === 0) {
            result = !resolveExpression(expression.substring(CONDITION_OPERATOR_NOT.length), definedProperties);
        }
        else {
            result = resolveConditionConstant(expression, definedProperties);
        }
        return result;
    };
    /**
     * Resolves a conditional directive and returns whether the condition is true based on defined properties.
     *
     * @param directive The conditional directive to resolve.
     * @param definedProperties An object containing defined expressions for condition resolution.
     * @returns `true` if the condition is true, `false` otherwise.
     */
    const resolveCondition = (directive, definedProperties) => {
        const expression = directive.substring(CONDITION_IF_DIRECTIVE_START.length).trim();
        return resolveExpression(expression, definedProperties);
    };
    /**
     * Resolves conditional directives in a list of filtering rules based on
     * defined properties.
     *
     * @param rules The list of filtering rules to resolve.
     * @param definedExpressions An object containing defined expressions for
     * condition resolution.
     *
     * @returns The resolved filtering rules after processing conditional directives.
     *
     * @throws Throws an error if invalid conditional directives are encountered.
     */
    const resolveConditions = (rules, definedExpressions) => {
        if (!definedExpressions) {
            return rules;
        }
        let result = [];
        for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            if (rule.indexOf(CONDITION_IF_DIRECTIVE_START) === 0) {
                const endLineIndex = findConditionBlockEnd(rules, CONDITION_DIRECTIVE_END, i + 1, rules.length);
                if (endLineIndex === -1) {
                    throw new Error(`Invalid directives: Condition end not found: ${rule}`);
                }
                const elseLineIndex = findConditionBlockEnd(rules, CONDITION_ELSE_DIRECTIVE_START, i + 1, endLineIndex);
                const isConditionMatched = resolveCondition(rule, definedExpressions);
                // if there is no 'else' branch for the condition
                if (elseLineIndex === -1) {
                    if (isConditionMatched) {
                        const rulesUnderCondition = rules.slice(i + 1, endLineIndex);
                        // Resolve inner conditions in recursion
                        result = result.concat(resolveConditions(rulesUnderCondition, definedExpressions));
                    }
                }
                else {
                    // check if there is something after !#else
                    if (rules[elseLineIndex].trim().length !== CONDITION_ELSE_DIRECTIVE_START.length) {
                        throw new Error(`Invalid directives: Found invalid !#else: ${rule}`);
                    }
                    if (isConditionMatched) {
                        const rulesForConditionTrue = rules.slice(i + 1, elseLineIndex);
                        // Resolve inner conditions in recursion
                        result = result.concat(resolveConditions(rulesForConditionTrue, definedExpressions));
                    }
                    else {
                        const rulesForConditionFalse = rules.slice(elseLineIndex + 1, endLineIndex);
                        // Resolve inner conditions in recursion
                        result = result.concat(resolveConditions(rulesForConditionFalse, definedExpressions));
                    }
                }
                // Skip to the end of block
                i = endLineIndex;
            }
            else if (rule.indexOf(CONDITION_ELSE_DIRECTIVE_START) === 0) {
                // Found !#else without !#if
                throw new Error(`Invalid directives: Found unexpected condition else branch: ${rule}`);
            }
            else if (rule.indexOf(CONDITION_DIRECTIVE_END) === 0) {
                // Found !#endif without !#if
                throw new Error(`Invalid directives: Found unexpected condition end: ${rule}`);
            }
            else {
                result.push(rule);
            }
        }
        return result;
    };
    /**
     * Validates a URL to ensure it matches the expected origin.
     *
     * @param url The URL to validate.
     * @param filterUrlOrigin The expected origin URL. If provided, the function
     * checks if the URL matches this origin.
     * @throws Throws an error if the URL is absolute and its origin doesn't
     * match the expected origin.
     */
    const validateUrl = (url, filterUrlOrigin) => {
        if (filterUrlOrigin) {
            if (REGEXP_ABSOLUTE_URL.test(url)) {
                // Include url is absolute
                const urlOrigin = getUrlOrigin(url);
                const filterOrigin = getUrlOrigin(filterUrlOrigin);
                if (urlOrigin !== filterOrigin) {
                    throw new Error(`Include url is rejected with origin: ${urlOrigin}`);
                }
            }
        }
    };
    /**
     * Validates and resolves include directive.
     *
     * @param line Line with directive.
     * @param {?string} filterOrigin Filter file URL origin or null.
     * @param {?object} definedProperties An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const resolveInclude = async (line, filterOrigin, definedProperties) => {
        if (line.indexOf(INCLUDE_DIRECTIVE) !== 0) {
            return Promise.resolve(line);
        }
        const url = line.substring(INCLUDE_DIRECTIVE.length).trim();
        validateUrl(url, filterOrigin);
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        const { filter } = await downloadFilterRules(url, true, filterOrigin, definedProperties);
        const MAX_LINES_TO_SCAN = 50;
        // Math.min inside for loop, because filter.length changes
        for (let i = 0; i < Math.min(MAX_LINES_TO_SCAN, filter.length); i += 1) {
            if (filter[i].trim().startsWith('! Diff-Path:')) {
                filter.splice(i, 1);
            }
        }
        return filter;
    };
    /**
     * Resolves include directives.
     *
     * @param rules Array of rules.
     * @param filterOrigin Filter file URL origin or null.
     * @param definedExpressions An object with the defined expressions for conditions resolution.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @returns A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const resolveIncludes = async (rules, filterOrigin, definedExpressions) => {
        const promises = rules.map((rule) => resolveInclude(rule, filterOrigin, definedExpressions));
        let result = [];
        // We do not use here Promise.all because it freezes the Chromium browsers and electron built on it, if there
        // are more than 1_100_00 promises. Also, we consider that wa can afford promises to be resolved sequentially.
        for (let i = 0; i < promises.length; i += 1) {
            // eslint-disable-next-line no-await-in-loop
            const resolved = await promises[i];
            if (Array.isArray(resolved)) {
                result = result.concat(resolved);
            }
            else {
                result.push(resolved);
            }
        }
        return result;
    };
    /**
     * Downloads filter rules from an external URL or a local path and resolves
     * pre-processor directives.
     *
     * @param url Filter file absolute URL or relative path.
     * @param filterUrlOrigin Filter file URL origin or null.
     * @param definedProperties An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @param resolveDirectives Whether to resolve pre-processor directives.
     *
     * @returns A promise that returns an array of strings with rules when
     * resolved or an Error if rejected.
     */
    const externalDownload = async (url, filterUrlOrigin, definedProperties, resolveDirectives) => {
        const filterUrl = !REGEXP_ABSOLUTE_URL.test(url) && REGEXP_ABSOLUTE_URL.test(filterUrlOrigin || '')
            // getting absolute url for external file with relative url
            ? `${filterUrlOrigin}/${url}`
            : url;
        if (!resolveDirectives) {
            const filter = await FileDownloadWrapper.getExternalFile(filterUrl);
            return {
                filter,
                rawFilter: filter,
            };
        }
        const filter = await FileDownloadWrapper.getExternalFile(filterUrl);
        const urlOrigin = getFilterUrlOrigin(filterUrl);
        const conditionsResult = resolveConditions(filter, definedProperties);
        const includesResult = await resolveIncludes(conditionsResult, urlOrigin, definedProperties);
        return {
            filter: includesResult,
            rawFilter: filter,
        };
    };
    /**
     * Compiles filter content.
     *
     * @param rules Array of strings.
     * @param filterOrigin Filter file URL origin or null.
     * @param definedProperties An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @returns A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const compile = (rules, filterOrigin, definedProperties) => {
        // Resolve 'if' conditions
        const resolvedConditionsResult = resolveConditions(rules, definedProperties);
        // Resolve 'includes' directives
        return resolveIncludes(resolvedConditionsResult, filterOrigin, definedProperties);
    };
    /**
     * Gets filter rules from a local path and resolves pre-processor directives.
     *
     * @param url Local path.
     * @param filterUrlOrigin Origin path.
     * @param definedProperties An object with the defined properties.
     * @param resolveDirectives Whether to resolve pre-processor directives.
     *
     * @returns A promise that returns an array of strings with rules when resolved or an Error if rejected.
     */
    const getLocalFile = async (url, filterUrlOrigin, definedProperties, resolveDirectives) => {
        const urlToLoad = filterUrlOrigin
            ? `${filterUrlOrigin}/${url}`
            : url;
        const origin = getFilterUrlOrigin(urlToLoad, filterUrlOrigin);
        if (!resolveDirectives) {
            const filter = await FileDownloadWrapper.getLocalFile(urlToLoad, origin);
            return {
                filter,
                rawFilter: filter,
            };
        }
        const rawFilter = await FileDownloadWrapper.getLocalFile(urlToLoad, origin);
        const urlOrigin = getFilterUrlOrigin(urlToLoad);
        // Resolve 'if' conditions and 'includes' directives
        const conditionsResult = resolveConditions(rawFilter, definedProperties);
        const includesResult = await resolveIncludes(conditionsResult, urlOrigin, definedProperties);
        return {
            filter: includesResult,
            rawFilter,
        };
    };
    /**
     * Downloads filter rules from a URL and resolves pre-processor directives.
     *
     * @param url Filter file URL.
     * @param resolveDirectives Whether to resolve pre-processor directives.
     * @param filterUrlOrigin Filter file URL origin or null.
     * @param definedProperties An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     *
     * @returns A promise that returns an array of strings with rules when
     * resolved or an Error if rejected.
     */
    const downloadFilterRules = (url, resolveDirectives = true, filterUrlOrigin, definedProperties) => {
        if (REGEXP_EXTERNAL_ABSOLUTE_URL.test(url) || REGEXP_EXTERNAL_ABSOLUTE_URL.test(filterUrlOrigin || '')) {
            return externalDownload(url, filterUrlOrigin, definedProperties, resolveDirectives);
        }
        return getLocalFile(url, filterUrlOrigin, definedProperties, resolveDirectives);
    };
    /**
     * Downloads a specified filter and resolves all the pre-processor directives from there.
     *
     * @param url Filter file URL.
     * @param definedProperties An object with the defined properties.
     * These properties might be used in pre-processor directives (`#if`, etc.).
     * @returns A promise that resolves with a list of rules and rejects with an error if unable to download.
     */
    const download = async (url, definedProperties) => {
        let filterUrlOrigin;
        if (url && REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)) {
            filterUrlOrigin = getFilterUrlOrigin(url);
        }
        const result = await downloadFilterRules(url, true, filterUrlOrigin, definedProperties);
        // only included filters can be empty
        if (result.filter && result.filter.join().trim() === '') {
            throw new Error('Response is empty');
        }
        return result.filter;
    };
    /**
     * Resolves conditions and includes based on the provided raw filter, options, and filter URL origin.
     *
     * @param rawFilter The raw filter to be resolved.
     * @param options The options used in the resolution process.
     * @param filterUrlOrigin The origin of the filter URL.
     *
     * @returns A Promise that resolves to the result of resolving the includes.
     */
    async function resolveConditionsAndIncludes(rawFilter, options, filterUrlOrigin) {
        const resolvedConditionsResult = resolveConditions(rawFilter, options.definedExpressions);
        return resolveIncludes(resolvedConditionsResult, filterUrlOrigin, options.definedExpressions);
    }
    /**
     * Downloads filter rules from a URL and resolves pre-processor directives.
     *
     * @param url Filter file URL.
     * @param options Options to be applied while downloading the filter.
     *
     * @returns A promise that returns an array of strings with rules.
     */
    async function downloadAndProcess(url, options) {
        let filterUrlOrigin;
        if (url && REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)) {
            filterUrlOrigin = getFilterUrlOrigin(url);
        }
        // `false` for not resolving directives
        const result = await downloadFilterRules(url, false, filterUrlOrigin);
        // only included filters can be empty
        if (result.filter && result.filter.join().trim() === '') {
            throw new Error('Response is empty');
        }
        const includesResult = await resolveConditionsAndIncludes(result.rawFilter, options, filterUrlOrigin);
        return {
            filter: includesResult,
            rawFilter: result.rawFilter,
        };
    }
    /**
     * Splits filter by lines.
     * @param filter Filter to split.
     * @returns Array of strings.
     */
    const splitFilter = (filter) => {
        return filter.trim().split(/[\r\n]+/);
    };
    /**
     * Downloads filter rules from a URL without resolving pre-processor directives.
     *
     * @param url Filter file URL.
     * @param options Options to be applied while downloading the filter.
     * @returns A promise that returns an array of strings with rules when
     * resolved or an Error if rejected.
     */
    const downloadWithRaw = async (url, options) => {
        options.verbose ??= false;
        options.force ??= false;
        let filterUrlOrigin;
        if (url && REGEXP_EXTERNAL_ABSOLUTE_URL.test(url)) {
            filterUrlOrigin = getFilterUrlOrigin(url);
        }
        // if options.force, then download the whole filter
        // if !options.rawFilter, then return result as is, since it is not possible to apply
        // patches without the raw filter
        if (options.force || !options.rawFilter) {
            return downloadAndProcess(url, options);
        }
        const rawFilter = await DiffUpdater_1.applyPatch({
            filterUrl: url,
            filterContent: options.rawFilter,
            verbose: options.verbose,
        });
        // applyPatch returns null if there is no Diff-Path in the filter metadata
        if (rawFilter === null) {
            return downloadAndProcess(url, options);
        }
        // if nothing changed, then return result as is
        if (rawFilter === options.rawFilter) {
            return {
                filter: splitFilter(rawFilter),
                rawFilter: splitFilter(options.rawFilter),
            };
        }
        const resolveResult = await resolveConditionsAndIncludes(splitFilter(rawFilter), options, filterUrlOrigin);
        return {
            filter: resolveResult,
            rawFilter: splitFilter(rawFilter),
        };
    };
    return {
        compile,
        download,
        downloadWithRaw,
        resolveConditions,
        resolveIncludes,
        getFilterUrlOrigin,
    };
};

const PREFERRED_CONTENT_TYPE = 'text/plain';
/**
 * Supported content types.
 */
const SUPPORTED_CONTENT_TYPES = [
    PREFERRED_CONTENT_TYPE,
    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1723
    'text/html',
];
/**
 * Returns content type error.
 *
 * @returns Error with description of supported content types.
 */
const getContentTypeError = () => {
    return new Error(`Response content type should be one of: "${SUPPORTED_CONTENT_TYPES.join(', ')}"`);
};
/**
 * Checks if the content type is supported.
 *
 * @param contentTypeHeader Content type header.
 *
 * @returns True if supported.
 */
const isContentTypeSupported = (contentTypeHeader) => {
    if (!contentTypeHeader) {
        return false;
    }
    return SUPPORTED_CONTENT_TYPES.some((ct) => contentTypeHeader.includes(ct));
};

/**
 * This file is part of AdGuard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * AdGuard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * AdGuard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with AdGuard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */
/**
 * Set of network protocols. Used to check if url is local.
 */
const networkProtocols = new Set(['http:', 'https:']);
/**
 * If url protocol is not http or https return true, else false.
 *
 * @param url URL address to check.
 *
 * @returns Tue if provided address is local.
 */
const isLocal = (url) => {
    const parsedUrl = new URL(url);
    return !networkProtocols.has(parsedUrl.protocol);
};
/**
 * Executes async request via fetch
 * fetch doesn't allow to download urls with file:// scheme.
 *
 * @param url URL.
 *
 * @returns Promise which will be resolved with string content of request
 * divided by '/r?/n'.
 */
const executeRequestAsyncFetch = async (url) => {
    const response = await fetch(url, {
        cache: 'no-cache',
        headers: {
            Pragma: 'no-cache',
            'Content-Type': PREFERRED_CONTENT_TYPE,
        },
    });
    if (response.status !== 200 && response.status !== 0) {
        throw new Error(`Response status for url ${url} is invalid: ${response.status}`);
    }
    // Don't check response headers if url is local,
    // because the edge extension doesn't provide headers for such url
    if (!isLocal(response.url)) {
        const responseContentType = response.headers.get('Content-Type');
        if (!isContentTypeSupported(responseContentType)) {
            throw getContentTypeError();
        }
    }
    const responseText = await response.text();
    const lines = responseText
        .trim()
        .split(/[\r\n]+/);
    return lines;
};
/**
 * Executes an asynchronous XMLHttpRequest to retrieve the content of a file
 * from the given URL.
 *
 * @param url The URL of the file to retrieve.
 * @returns A Promise that resolves to an array of strings representing
 * the lines of the file.
 * @throws Throws an error if the response status is invalid,
 * the Content-Type is unsupported,
 * or if there's an error during the request.
 */
const executeRequestAsyncXhr = (url) => new Promise((resolve, reject) => {
    const onRequestLoad = (response) => {
        if (response.status !== 200 && response.status !== 0) {
            reject(new Error(`Response status for url ${url} is invalid: ${response.status}`));
        }
        const responseText = response.responseText
            ? response.responseText
            // @ts-ignore
            : response.data;
        // Don't check response headers if url is local,
        // because the edge extension doesn't provide headers for such url
        if (!isLocal(response.responseURL)) {
            const responseContentType = response.getResponseHeader('Content-Type');
            if (!isContentTypeSupported(responseContentType)) {
                reject(getContentTypeError());
            }
        }
        const lines = responseText
            .trim()
            .split(/[\r\n]+/);
        resolve(lines);
    };
    const request = new XMLHttpRequest();
    try {
        request.open('GET', url);
        request.setRequestHeader('Pragma', 'no-cache');
        request.overrideMimeType(PREFERRED_CONTENT_TYPE);
        // @ts-ignore
        request.mozBackgroundRequest = true;
        // eslint-disable-next-line func-names
        request.onload = () => {
            onRequestLoad(request);
        };
        request.onerror = () => reject(new Error(`Request error happened: ${request.statusText || 'status text empty'}`));
        request.onabort = () => reject(new Error(`Request was aborted with status text: ${request.statusText}`));
        request.ontimeout = () => reject(new Error(`Request timed out with status text: ${request.statusText}`));
        request.send(null);
    }
    catch (ex) {
        reject(ex);
    }
});
/**
 * Downloads filter rules from external url.
 *
 * @param url Filter file absolute URL or relative path.
 * @returns A promise that returns array of string rules when resolved
 * and error if rejected.
 */
const getExternalFile = (url) => executeRequestAsyncFetch(url);
/**
 * Retrieves a local file content asynchronously using XMLHttpRequest or fetch API.
 *
 * @param url The URL of the local file to retrieve.
 * @returns A Promise that resolves to an array of strings representing
 * the lines of the file.
 * @throws Throws an error if neither XMLHttpRequest nor fetch is available or
 * if getting local files inside a service worker is not supported.
 */
const getLocalFile = (url) => {
    if (typeof XMLHttpRequest !== 'undefined') {
        return executeRequestAsyncXhr(url);
    }
    if (typeof fetch !== 'undefined') {
        return executeRequestAsyncFetch(url);
    }
    throw new Error('XMLHttpRequest or fetch are undefined, getting local files inside service worker is not working');
};

const FiltersDownloader = FiltersDownloaderCreator({
    getLocalFile,
    getExternalFile,
});

export { FiltersDownloader };
